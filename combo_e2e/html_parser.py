import logging

from copy import deepcopy
from pathlib import Path
from typing import List, Optional, Dict, Tuple

from combo_e2e.config import config
from combo_e2e.helpers.const import (
    PAGE_PATH_NAME,
    NAV_PAGE_PATH_NAME,
    RAW_PAGE_CLASS_POSTFIX,
    RAW_PAGE_PATH_NAME,
)
from combo_e2e.helpers.exceptions import ParserException
from combo_e2e.pages import \
    BasePage, BasePageMeta, BaseNavigation, BaseNavigationMeta, ElementDescriptor, WebElementProxy
from combo_e2e.helpers.utils import Utils, RelativeImportPath, LineRange
from lxml.etree import XMLSyntaxError
from selenium.webdriver.common.by import By

from lxml.html import HtmlElement

logger = logging.getLogger(__name__)

EMPTY_CLASS_BODY = '    pass\n'

PAGE_CLASS_REPR = """\
\"""
Class inherited from autogenerated class, can be edited
\"""
# put new imports here
{additional_imports}


class {page_class}({raw_page_class}, metaclass={base_metaclass}):
"""

RAW_NAV_CLASS_REPR = """\
\"""
Autogenerated class, not to be edited
\"""
# put new imports from non project libraries here
from typing import List
{additional_imports}


class {raw_page_class}({base_page_class}):
"""

RAW_PAGE_CLASS_REPR = """\
\"""
Autogenerated class, not to be edited
\"""
# put new imports from non project libraries here
from typing import List
{additional_imports}


class {raw_page_class}({base_page_class}):
    page_url = '{page_url}'
    app_name = '{app_name}'
"""

ATTRIBUTE_REPR = """\
    {attribute_name}: {attribute_annotation} = {attribute_value}
    \"""{path_to_attribute}\"""
"""
NAV_CLASS_OBJ_REPR = """\
    {attr_name}: {class_name} = {class_name}()
"""

XPATH_BY_CSS = r"""'//*[contains(@class, "{class_name}")]'"""
XPATH_BY_TAG_ATTR = r"""'//*[@{attr_name}="{attr_value}"]'"""


class PageHelper:
    html_obj: HtmlElement = None
    """object containing tree of current page"""

    py_page_file_name: str = None
    """the name of the module into which the class describing the current page will be written"""
    path_to_write_raw_page: Path = None
    """full path to write "raw" class"""
    path_to_write_page: Path = None
    """full path to write main class"""

    class_name: str = None
    """main page class name"""
    raw_class_name: str = None
    """'raw' page class name"""
    attributes: List[str] = []
    """raw class attributes that were found in the original page (already converted to py strings)"""
    base_page_import_path: str = None
    """path of the relative import of BasePage into the "raw" class module"""
    base_meta_page_import_path: str = None
    """path of the relative import of BasePageMeta into the base class module"""
    raw_page_import_path: str = None
    """path of relative import of raw class into base class module"""
    element_descriptor_and_proxy_import_path: str = None
    """path of relative import of WebElementProxy and ElementDescriptor classes into the module of "raw" class"""


class AngularFormatParser:
    """
    base parser class. To implement a parser for angular application, you need inherit from it.
    For each page of the angular application, two files are generated:
    e2e--pages--<page_name>
       |-raw_pages--<page_name>
    pages contains GeneratedClass - base class which should be imported into tests
    raw_pages contains GeneratedClassRaw - "raw" class which is filled with autogenerated attributes
    Inheritance structure:
    BasePage->GeneratedClassRaw->GeneratedClass(metaclass=BasePageMeta)

    GeneratedClassRaw is filled with attributes which are WebElementProxy proxy-objects, acquired 
    though ElementDescriptor
    """

    app_name: str = None
    """the name of the angular application (the name of the subdirectory in js), set in inheriting classes"""

    relative_app_path: Path = None
    """relative path to the root of the js-application, set in inheriting classes"""
    project_path: Path = None
    """absolute path to the root of the project, set in inheriting classes"""
    app_path: Path = None
    """absolute path to the root of the js application, generated at runtime"""
    relative_e2e_path: Path = None
    """relative path to the e2e folder, set in inheriting classes"""
    e2e_path: Path = None
    """absolute path to the e2e folder, generated at runtime"""
    pages_path: Path = None
    """absolute path to the folder with template pages that can be edited, generated at runtime"""
    raw_pages_path: Path = None
    """absolute path to the folder with auto-generated pages, generated at runtime"""

    base_attrs_search_patterns = ['name', config.DATA_E2E_ATTRIBUTE, ]

    components_relative_path: Path = None
    """pages path, relative to relative_app_path"""
    head_relative_path: Path = None
    """path to file with head layout, relative to relative_app_path"""
    side_nav_relative_path: Path = None
    """path ot file with side navigation menu, relative to relative_app_path"""
    footer_relative_path: Path = None
    """path ot file with footer layout, relative to relative_app_path"""
    navigation_classes_import_list: List[Tuple[str, Path]] = []
    """classes and full paths of navigation classes common to all pages"""

    @classmethod
    def _set_project_paths(cls) -> None:
        if not cls.relative_app_path:
            raise NotImplementedError('relative_app_path attr must be set to subclass')

        cls.e2e_path = cls.project_path.joinpath(cls.relative_e2e_path)
        cls.app_path = cls.project_path.joinpath(cls.relative_app_path)

    @classmethod
    def _set_pages_paths(cls) -> None:
        if not cls.app_name:
            raise NotImplementedError('app_name attr must be set to subclass')

        cls.pages_path = cls.e2e_path.joinpath(PAGE_PATH_NAME, cls.app_name)
        Utils.create_module_dir(module_path=cls.pages_path)
        cls.raw_pages_path = cls.e2e_path.joinpath(RAW_PAGE_PATH_NAME, cls.app_name)
        Utils.create_module_dir(module_path=cls.raw_pages_path)

    @classmethod
    def parse(cls) -> None:
        """
        Performs all the necessary parsing actions.
        Inheriting class should have create_navigation_components and custom_parse methods
        :return:
        """
        cls._set_project_paths()
        cls._set_pages_paths()
        cls.create_navigation_components()
        cls.custom_parse()

    @classmethod
    def create_navigation_components(cls) -> None:
        """
        Creates base components present on every page (nav panel etc.)
        Should be implemented in inheriting class. create_footer, create_side_nav
        or create_head can be called inside, with params required for a specific application.
        :return:
        """
        raise NotImplementedError('method create_navigation_components must be implemented')

    @classmethod
    def custom_parse(cls) -> None:
        """
        this method shoud contain specific logic for parsing main pages of the project
        since every js application has different elements placement.
        parse_pages or create_page high-level functions can be called inside,
        with params required for a specific application.
        :return:
        """
        raise NotImplementedError('method custom_parse() must be implemented')

    @classmethod
    def create_footer(cls) -> None:
        """
        Creates class with page footer description.
        Should be called within create_navigation_components.
        :return:
        """
        if cls.footer_relative_path:
            path = cls.app_path.joinpath(cls.footer_relative_path)
            cls._create_navigation(path)

    @classmethod
    def create_side_nav(cls, css_patterns: Optional[List[str]] = None, patterns_by_attr: Optional[List[str]] = None,
                        file_name_prefix: Optional[str] = None, search_range: Optional[LineRange] = None,
                        raw_page_custom_attr: Optional[List[str]] = None) -> None:
        """
        Creates class with left nav panel description.
        Should be called within create_navigation_components.
        :param css_patterns: list of css-classes used to search for custom element
        :param patterns_by_attr: list of attribute names used to search for custom element
        :param file_name_prefix: prefix to the auto-generated filename where the navigation class will be saved
        :param search_range: LineRange object, if search for elements in a certain range of lines in the file is needed
        :param raw_page_custom_attr: pre-defined custom attributes (if element cannot be found using css/attributes
        patterns)
        :return:
        """
        if cls.side_nav_relative_path:
            path = cls.app_path.joinpath(cls.side_nav_relative_path)
            cls._create_navigation(path, custom_css_patterns=css_patterns, custom_patterns_by_attr=patterns_by_attr,
                                   file_name_prefix=file_name_prefix, search_range=search_range,
                                   raw_page_custom_attr=raw_page_custom_attr, )

    @classmethod
    def create_head(cls, file_name_prefix: Optional[str] = None, search_range: Optional[LineRange] = None,
                    raw_page_custom_attr: Optional[List[str]] = None) -> None:
        """
        Creates class with header description
        Should be called within create_navigation_components
        :param file_name_prefix: prefix to the auto-generated filename where the navigation class will be saved
        :param search_range: LineRange object, if search for elements in a certain range of lines in the file is needed
        :param raw_page_custom_attr: pre-defined custom attributes (if element cannot be found using css/attributes
        patterns)
        :return:
        """
        if cls.head_relative_path:
            path = cls.app_path.joinpath(cls.head_relative_path)
            cls._create_navigation(path, file_name_prefix=file_name_prefix, search_range=search_range,
                                   raw_page_custom_attr=raw_page_custom_attr, )

    @classmethod
    def parse_pages(cls, pages_routes: Dict[str, str]) -> None:
        """
        Parses all html pages contained in components_relative_path and its subdirectories
        :param pages_routes: {<relative_path_to_page>: <relative_page_url>} dictionary
        :return:
        """
        components_path: Path = cls.app_path.joinpath(cls.components_relative_path)
        added_names = set()

        for path in components_path.iterdir():
            if path.is_dir():
                html_paths = list(path.rglob('*.html'))
                names = [p.stem for p in html_paths]
                has_same_names = len(names) != len(set(names))
                for p in html_paths:
                    name_prefix = ''
                    if p.parent != path and has_same_names:
                        name_prefix = p.relative_to(path).parent.name.split('-')[-1]
                    cls.create_page(p, page_url=pages_routes.get(p.stem, ''), file_name_prefix=name_prefix)
                    added_names.add(p.name)

    @classmethod
    def create_page(cls, path_to_html: Path, custom_css_patterns: Optional[List[str]] = None,
                    custom_patterns_by_attr: Optional[List[str]] = None, page_url: str = "",
                    file_name_prefix: Optional[str] = None, search_range: Optional[LineRange] = None) -> None:
        """
        Used in parse_pages(), but can be called separately to parse additional pages that are not in directory 
        specified in components_relative_path
        :param path_to_html: absolute path to source file
        :param custom_css_patterns: list of css-classes used to search for custom element
        :param custom_patterns_by_attr: list of attribute names to search for custom element
        :param page_url: relative url (without domain), used to open page in browser
        :param file_name_prefix: prefix to the auto-generated filename where the navigation class will be saved
        :param search_range: LineRange object, if search for elements in a certain range of lines in the file is needed
        :return:
        """
        try:
            obj: PageHelper = cls._parse_html(path_to_html, custom_css_patterns, custom_patterns_by_attr,
                                              file_name_prefix=file_name_prefix, search_range=search_range, )
        except XMLSyntaxError:
            logger.warning('File %s is empty or have invalid syntax. Skip parsing', path_to_html)
            return

        additional_imports = [
            obj.base_page_import_path,
        ]
        if obj.attributes:
            additional_imports.append(obj.element_descriptor_and_proxy_import_path)

        page_raw = RAW_PAGE_CLASS_REPR.format(
            raw_page_class=obj.raw_class_name,
            additional_imports='\n'.join(additional_imports),
            base_page_class=BasePage.__name__,
            page_url=page_url,
            app_name=cls.app_name,
            base_metaclass=BasePageMeta.__name__,
        )

        page_attrs, page_imports = cls._get_navigations_for_page(path_to_write_page=obj.path_to_write_page)
        page_imports.extend([obj.base_meta_page_import_path, obj.raw_page_import_path])

        page = PAGE_CLASS_REPR.format(
            page_class=obj.class_name,
            raw_page_class=obj.raw_class_name,
            base_metaclass=BasePageMeta.__name__,
            additional_imports='\n'.join(page_imports),
        )

        cls._create_page_file(obj.path_to_write_raw_page, page_raw, obj.attributes, rewrite=True)
        cls._create_page_file(obj.path_to_write_page, page, page_attrs or [EMPTY_CLASS_BODY])

        cls._add_page_class_to_init_file(obj.path_to_write_page, obj.class_name)

    @classmethod
    def _parse_html(cls, path_to_html: Path, custom_css_patterns: Optional[List[str]] = None,
                    custom_patterns_by_attr: Optional[List[str]] = None,
                    is_nav_component: bool = False, file_name_prefix: str = '',
                    search_range: Optional[LineRange] = None) -> PageHelper:
        """
        Main method used to parse html pages. Collects data common to all pages
        and returns a PageHelper object. Not to be called directly.
        :param path_to_html:
        :param custom_css_patterns:
        :param custom_patterns_by_attr:
        :param is_nav_component:
        :param file_name_prefix: prefix to the name of the generated module file
        :param search_range: line range to search inside the file (if whole file is not needed)
        :return:
        """
        obj: PageHelper = PageHelper()
        obj.html_obj = Utils.get_html_from_file(path=path_to_html)
        file_name = Path('_'.join(filter(lambda o: o, [file_name_prefix, path_to_html.name])))

        obj.class_name = Utils.get_class_name_from_file_name(file_name)
        obj.raw_class_name = f'{obj.class_name}{RAW_PAGE_CLASS_POSTFIX}'

        obj.py_page_file_name = Utils.get_python_format_file_name(file_name)
        obj.path_to_write_page = cls._get_path_to_write(cls.pages_path, obj.py_page_file_name, is_nav_component)
        obj.path_to_write_raw_page = cls._get_path_to_write(cls.raw_pages_path, obj.py_page_file_name, is_nav_component)

        obj.attributes = cls._search_named_tags(page=obj.html_obj, path_to_html=path_to_html,
                                                custom_css_patterns=custom_css_patterns,
                                                custom_patterns_by_attr=custom_patterns_by_attr,
                                                search_range=search_range,
                                                )

        base_class = BaseNavigation if is_nav_component else BasePage
        base_metaclass = BaseNavigationMeta if is_nav_component else BasePageMeta

        obj.base_page_import_path = f'from {base_class.__module__} import {base_class.__name__}'

        obj.base_meta_page_import_path =  f'from {base_metaclass.__module__} import {base_metaclass.__name__}'

        obj.element_descriptor_and_proxy_import_path = \
            f'from {ElementDescriptor.__module__} import {ElementDescriptor.__name__}, {WebElementProxy.__name__}'

        obj.raw_page_import_path = RelativeImportPath.get(
            root=cls.e2e_path,
            to_path=obj.path_to_write_page,
            from_path=obj.path_to_write_raw_page,
            class_names=[obj.raw_class_name],
        )

        return obj

    @classmethod
    def _get_path_to_write(cls, pages_root: Path, file_name: Path, is_nav_component: bool) -> Path:
        if is_nav_component:
            pages_root = pages_root.joinpath(NAV_PAGE_PATH_NAME)
            Utils.create_module_dir(pages_root)
        return pages_root.joinpath(file_name)

    @classmethod
    def _create_navigation(cls, path_to_html: Path, custom_css_patterns: Optional[List[str]] = None,
                           custom_patterns_by_attr: Optional[List[str]] = None,
                           file_name_prefix: Optional[str] = None, search_range: Optional[LineRange] = None,
                           raw_page_custom_attr: Optional[List[str]] = None) -> None:
        """
        Creates classes for the navigation parts of the page
        :param path_to_html:
        :param custom_css_patterns:
        :param custom_patterns_by_attr:
        :param file_name_prefix:
        :param search_range:
        :param raw_page_custom_attr:
        :return:
        """
        obj: PageHelper = cls._parse_html(path_to_html, custom_css_patterns, custom_patterns_by_attr,
                                          is_nav_component=True, file_name_prefix=file_name_prefix,
                                          search_range=search_range, )

        additional_imports = [
            obj.base_page_import_path,
        ]
        if obj.attributes or raw_page_custom_attr:
            additional_imports.append(obj.element_descriptor_and_proxy_import_path)

        page_raw = RAW_NAV_CLASS_REPR.format(
            raw_page_class=obj.raw_class_name,
            additional_imports='\n'.join(additional_imports),
            base_page_class=BaseNavigation.__name__,
        )

        page = PAGE_CLASS_REPR.format(
            page_class=obj.class_name,
            raw_page_class=obj.raw_class_name,
            additional_imports='\n'.join([obj.base_meta_page_import_path, obj.raw_page_import_path]),
            base_metaclass=BaseNavigationMeta.__name__,
        )

        if raw_page_custom_attr:
            obj.attributes.extend(raw_page_custom_attr)

        cls._create_page_file(obj.path_to_write_raw_page, page_raw, obj.attributes or [EMPTY_CLASS_BODY], rewrite=True)
        cls._create_page_file(obj.path_to_write_page, page, [EMPTY_CLASS_BODY])

        init_file_path: Path = cls._add_page_class_to_init_file(obj.path_to_write_page, obj.class_name)
        cls.navigation_classes_import_list.append((obj.class_name, init_file_path))

    @classmethod
    def _get_navigations_for_page(cls, path_to_write_page: Path) -> Tuple[List[str], List[str]]:
        """
        Creates navigation attributes from navigation classes for each base page
        :param path_to_write_page: absolute path to the module to import to
        :return:
        """
        attrs = []
        classes_imports = []
        for class_name, full_path in cls.navigation_classes_import_list:
            attr = NAV_CLASS_OBJ_REPR.format(class_name=class_name, attr_name=class_name.lower())
            attrs.append(attr)
            class_import = RelativeImportPath.get(
                root=cls.e2e_path,
                to_path=path_to_write_page,
                from_path=full_path,
                class_names=[class_name]
            )
            classes_imports.append(class_import)

        return attrs, classes_imports

    @classmethod
    def _create_page_file(cls, path: Path, page_header: str, page_attrs: List[str],
                          rewrite: bool = False) -> None:
        """
        Writes generated classes to files
        :param path: absolute path of the file to write to
        :param page_header: stringified class header and imports
        :param page_attrs: stringified class attributes
        :param rewrite: flag indicating whether to overwrite the file
        :return:
        """
        if not rewrite and path.exists():
            logger.info('Path "%s" already exists. It will not be rewritten', path)
            return

        with path.open('w') as f:
            f.write(page_header)
            if page_attrs:
                for attr in page_attrs:
                    f.write(attr)

    @classmethod
    def _add_page_class_to_init_file(cls, from_path: Path, class_name: str) -> Path:
        """
        adds import of new class to init file
        :param from_path:
        :param class_name:
        :return:
        """
        init_path: Path = from_path.parent.joinpath('__init__.py')
        import_path: str = RelativeImportPath.get(
            root=cls.e2e_path,
            to_path=init_path,
            from_path=from_path,
            class_names=[class_name]
        )

        with init_path.open('r') as f:
            data = f.read()
            if import_path in data:
                return init_path
        with init_path.open('a') as f:
            f.write(f'{import_path}\n')
        return init_path

    @classmethod
    def _search_named_tags(cls, page: HtmlElement, path_to_html: Path, custom_css_patterns: List[str] = None,
                           custom_patterns_by_attr: List[str] = None,
                           search_range: Optional[LineRange] = None) -> List[str]:
        """
        Main function implementing search for class attributes
        :param page: html object
        :param path_to_html: absolute path to the html file
        :param custom_css_patterns: list of css-classes used to search for custom element
        :param custom_patterns_by_attr: list of attribute names to search for custom element
        :param search_range: LineRange object, if search for elements in a certain range of lines in the file is needed
        :return:
        """
        attrs = []
        patterns_by_attr = deepcopy(cls.base_attrs_search_patterns)
        if custom_patterns_by_attr:
            patterns_by_attr.extend(custom_patterns_by_attr)

        if custom_css_patterns:
            attrs.extend(cls._search_by_css_patterns(page, path_to_html, custom_css_patterns, search_range))
        if patterns_by_attr:
            attrs.extend(cls._search_by_tag_attr_patterns(page, path_to_html, patterns_by_attr, search_range))

        return attrs

    @classmethod
    def _search_by_css_patterns(cls, page: HtmlElement, path_to_html: Path, custom_css_patterns: List[str],
                                search_range: Optional[LineRange] = None) -> List[str]:
        """
        Function implementing search for attributes by css class
        :param page:
        :param path_to_html:
        :param custom_css_patterns:
        :param search_range:
        :return: found attribute formatted to write to py file
        """
        res = []
        for pattern in custom_css_patterns:
            el = page.find_class(pattern)
            if not el:
                logger.warning('Element not found by custom css pattern <%s>', pattern)
            if len(el) > 1:
                raise ParserException('By custom css pattern <%s> found more then one elements: %s',
                                      pattern, el)
            if search_range and el.sourceline not in search_range:
                logger.warning('Element found by custom css pattern <%s> not in search %s', pattern, search_range)
            res.append(cls._format_element_by_css(path_to_html=path_to_html, element=el[0], css_class=pattern))
        return res

    @classmethod
    def _format_element_by_css(cls, path_to_html: Path, element: HtmlElement, css_class: str) -> str:
        """
        formats the found html element according to the css pattern into an attribute of the generated python class
        :param path_to_html:
        :param element:
        :param css_class:
        :return:
        """
        xpath = XPATH_BY_CSS.format(class_name=css_class)
        attribute_value = cls._format_attribute_value(xpath=xpath, many=False)
        return cls._print_element_in_py_repr(element, css_class, attribute_value, path_to_html, many=False)

    @classmethod
    def _search_by_tag_attr_patterns(cls, page: HtmlElement, path_to_html: Path, custom_patterns_by_attr: List[str],
                                     search_range: Optional[LineRange] = None) -> List[str]:
        """
        A function that implements the search for attributes by their attributes
        :param page:
        :param path_to_html:
        :param custom_patterns_by_attr:
        :param search_range:
        :return: found attribute formatted to write to py file
        """
        res = []
        for attr_name in custom_patterns_by_attr:
            if not page:
                continue
            prepared_name = attr_name.lower()
            search_mask = f'//*[@{prepared_name}]'
            elements: List[HtmlElement] = page.xpath(search_mask)
            if elements:
                added_elements: Dict[str, List] = {}
                for el in elements:
                    if search_range and el.sourceline not in search_range:
                        continue
                    attr_value = el.attrib[prepared_name]
                    if '{{' in attr_value:
                        # пропускаем элементы у которых атрибут формируется во время выполнения
                        continue
                    if attr_value in added_elements:
                        added_elements[attr_value][3] = True
                        continue
                    added_elements[attr_value] = [path_to_html, el, prepared_name, False]
                for element_data in added_elements.values():
                    res.append(cls._format_element_by_attribute(*element_data))
        return res

    @classmethod
    def _format_element_by_attribute(cls, path_to_html: Path, element: HtmlElement, attr_name: str, many: bool) -> str:
        """
        formats the found html element according to the attribute pattern into an attribute of the generated python class
        :param path_to_html:
        :param element:
        :param attr_name: attribute name
        :param many: flag if more than 1 element was found by attribute value
        :return:
        """
        xpath = XPATH_BY_TAG_ATTR.format(
            attr_name=attr_name,
            attr_value=element.attrib[attr_name],
        )
        property_name = '_'.join([attr_name, element.attrib[attr_name]])
        attribute_value = cls._format_attribute_value(xpath=xpath, many=many)
        return cls._print_element_in_py_repr(element, property_name, attribute_value, path_to_html, many)

    @classmethod
    def _format_attribute_value(cls, xpath: str, many: bool):
        """
        creates a python representation of the attribute
        :param xpath:
        :param many:
        :return:
        """
        proxy_class = ElementDescriptor.__name__
        search_by = By.XPATH
        return f"{proxy_class}(search_by='{search_by}', value=r{xpath}, many={many})"

    @classmethod
    def _print_element_in_py_repr(cls, element: HtmlElement, property_name: str,
                                  attribute_value: str, path_to_html: Path, many: bool):
        """
        formats the found html page element into a python view (i.e. into a class attribute)
        :param element:
        :param property_name: property name by which html element was found
        :param attribute_value: the name of the attribute to be assigned in the class
        :param path_to_html: absolute path to html
        :param many: flag if more than 1 element was found by attribute value
        :return:
        """
        formatted_property_name = Utils.format_name_to_python_format(name=property_name)
        name = Utils.make_attribute_name(tag_name=element.tag, property_name=formatted_property_name)
        relative_path_to_html = path_to_html.relative_to(cls.project_path)
        annotation = f'{List.__name__}[{WebElementProxy.__name__}]' if many else WebElementProxy.__name__
        kwargs = {
            'attribute_name': name,
            'attribute_annotation': annotation,
            'attribute_value': attribute_value,
            'path_to_attribute': Utils.path_with_row_number(relative_path_to_html, element.sourceline),
        }
        return ATTRIBUTE_REPR.format(**kwargs)
